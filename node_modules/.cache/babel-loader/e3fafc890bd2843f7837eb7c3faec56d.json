{"ast":null,"code":"var t = require(\"preact\");\n\nfunction n(t, n) {\n  for (var r in n) t[r] = n[r];\n\n  return t;\n}\n\nfunction r(t) {\n  this.getChildContext = function () {\n    return {\n      store: t.store\n    };\n  };\n}\n\nr.prototype.render = function (t) {\n  return t.children && t.children[0] || t.children;\n}, exports.connect = function (r, e) {\n  var o;\n  return \"function\" != typeof r && (\"string\" == typeof (o = r || {}) && (o = o.split(/\\s*,\\s*/)), r = function (t) {\n    for (var n = {}, r = 0; r < o.length; r++) n[o[r]] = t[o[r]];\n\n    return n;\n  }), function (o) {\n    function i(i, u) {\n      var c = this,\n          f = u.store,\n          s = r(f ? f.getState() : {}, i),\n          a = e ? function (t, n) {\n        \"function\" == typeof t && (t = t(n));\n        var r = {};\n\n        for (var e in t) r[e] = n.action(t[e]);\n\n        return r;\n      }(e, f) : {\n        store: f\n      },\n          p = function () {\n        var t = r(f ? f.getState() : {}, i);\n\n        for (var n in t) if (t[n] !== s[n]) return s = t, c.setState({});\n\n        for (var e in s) if (!(e in t)) return s = t, c.setState({});\n      };\n\n      this.componentWillReceiveProps = function (t) {\n        i = t, p();\n      }, this.componentDidMount = function () {\n        f.subscribe(p);\n      }, this.componentWillUnmount = function () {\n        f.unsubscribe(p);\n      }, this.render = function (r) {\n        return t.h(o, n(n(n({}, a), r), s));\n      };\n    }\n\n    return (i.prototype = new t.Component()).constructor = i;\n  };\n}, exports.Provider = r;","map":{"version":3,"sources":["src/util.js","src/integrations/preact.js"],"names":["actions","store","mapped","let","i","action","properties","split","state","selected","length","assign","obj","props","mapStateToProps","Child","Wrapper","context","getState","boundActions","mapActions","update","this","setState","componentWillReceiveProps","p","componentDidMount","subscribe","componentWillUnmount","unsubscribe","render","h","prototype","Component","constructor","Provider","getChildContext","children"],"mappings":";;AAyBO,SAASW,CAAT,CAAgBC,CAAhB,EAAqBC,CAArB,EAAqBA;AAAAA,OACtBV,IAAIC,CADkBS,IACbA,CADaA,EACND,CAAAA,CAAIR,CAAJQ,CAAAA,GAASC,CAAAA,CAAMT,CAANS,CAATD;;AAAeR,SAC7BQ,CAD6BR;ACqC9B;;AAAA,SAAS+B,CAAT,CAAkBtB,CAAlB,EAAkBA;AAAAA,OACnBuB,eADmBvB,GACnBuB,YAAAA;AAAAA,WAAAA;AAA2BnC,MAAAA,KAAAA,EAAOY,CAAAA,CAAMZ;AAAxCmC,KAAAA;AAAwCnC,GADrBY;AAGzBsB;;AAAAA,CAAAA,CAASH,SAATG,CAAmBL,MAAnBK,GAAmBL,UAASjB,CAATiB,EAASjB;AAAAA,SAASA,CAAAA,CAAMwB,QAANxB,IAAkBA,CAAAA,CAAMwB,QAANxB,CAAe,CAAfA,CAAlBA,IAAuCA,CAAAA,CAAMwB,QAAtDxB;AAAsDwB,CAAlFF,EAAkFE,OAAAA,CAAAA,OAAAA,GAjD3E,UAAiBvB,CAAjB,EAAkCd,CAAlC,EAAkCA;ADLlC,MAAgBM,CAAhB;AAAgBA,SCMM,cAAA,OAAjBQ,CAAiB,KDLJ,YAAA,QADFR,CAAAA,GCOIQ,CAAAA,IAAmB,EDNrB,CAAA,KAAUR,CAAAA,GAAaA,CAAAA,CAAWC,KAAXD,CAAiB,SAAjBA,CAAvB,GCMvBQ,CAAAA,GAAAA,UDLMN,CCKNM,EDLMN;AAAAA,SAAAA,IACFC,CAAAA,GAAW,EADTD,EAEGJ,CAAAA,GAAE,CAFLI,EAEQJ,CAAAA,GAAEE,CAAAA,CAAWI,MAFrBF,EAE6BJ,CAAAA,EAF7BI,EAGLC,CAAAA,CAASH,CAAAA,CAAWF,CAAXE,CAATG,CAAAA,GAA0BD,CAAAA,CAAMF,CAAAA,CAAWF,CAAXE,CAANE,CAA1BC;;AAA2CL,WAErCK,CAFqCL;AAErCK,GCDoB,GDCpBA,UCEDM,CDFCN,ECEDM;AAAAA,aACGC,CADHD,CACWF,CADXE,EACkBE,CADlBF,EACkBE;AAAAA,UAAAA,CAAAA,GAAAA,IAAAA;AAAAA,UACjBhB,CAAAA,GAAQgB,CAAAA,CAAQhB,KADCgB;AAAAA,UAEnBT,CAAAA,GAAQM,CAAAA,CAAgBb,CAAAA,GAAQA,CAAAA,CAAMiB,QAANjB,EAARA,GAA2B,EAA3Ca,EAA+CD,CAA/CC,CAFWG;AAAAA,UAGjBE,CAAAA,GAAenB,CAAAA,GDxBjB,UAAoBA,CAApB,EAA6BC,CAA7B,EAA6BA;AACd,sBAAA,OAAVD,CAAU,KAAYA,CAAAA,GAAUA,CAAAA,CAAQC,CAARD,CAAtB;AAA8BC,YAC/CC,CAAAA,GAAS,EADsCD;;AACtC,aACRE,IAAIC,CADI,IACCJ,CADD,EAEZE,CAAAA,CAAOE,CAAPF,CAAAA,GAAYD,CAAAA,CAAMI,MAANJ,CAAaD,CAAAA,CAAQI,CAARJ,CAAbC,CAAZC;;AAAiCE,eAE3BF,CAF2BE;ACoBDgB,ODxB3B,CCwBsCpB,CDxBtC,ECwB+CC,CDxB/C,CCwBiBD,GAAuC;AAAA,QAAA,KAAA,EAAEC;AAAF,OAHrCgB;AAAAA,UAInBI,CAAAA,GAAAA,YAAAA;AAAAA,YACCnB,CAAAA,GAASY,CAAAA,CAAgBb,CAAAA,GAAQA,CAAAA,CAAMiB,QAANjB,EAARA,GAA2B,EAA3Ca,EAA+CD,CAA/CC,CADVO;;AACyDR,aACvDV,IAAIC,CADmDS,IAC9CX,CAD8CW,EACtC,IAAIX,CAAAA,CAAOE,CAAPF,CAAAA,KAAYM,CAAAA,CAAMJ,CAANI,CAAhB,EAAsBJ,OAC3CI,CAAAA,GAAQN,CAARM,EACOc,CAAAA,CAAKC,QAALD,CAAc,EAAdA,CAFoClB;;AAEtB,aAEjBD,IAAIC,CAFa,IAERI,CAFQ,EAED,IAAA,EAAMJ,CAAAA,IAAKF,CAAX,CAAA,EAAWA,OAC/BM,CAAAA,GAAQN,CAARM,EACOc,CAAAA,CAAKC,QAALD,CAAc,EAAdA,CAFwBpB;AAEV,OAZAe;;AAYA,WAGlBO,yBAHkB,GAGlBA,UAA4BC,CAA5BD,EAA4BC;AAChCZ,QAAAA,CAAAA,GAAQY,CAARZ,EACAQ,CAAAA,EADAR;AACAQ,OALsB,EAKtBA,KAEIK,iBAFJL,GAEIK,YAAAA;AACJzB,QAAAA,CAAAA,CAAM0B,SAAN1B,CAAgBoB,CAAhBpB;AAAgBoB,OARM,EAQNA,KAEZO,oBAFYP,GAEZO,YAAAA;AACJ3B,QAAAA,CAAAA,CAAM4B,WAAN5B,CAAkBoB,CAAlBpB;AAAkBoB,OAXI,EAWJA,KAEdS,MAFcT,GAEdS,UAASjB,CAATiB,EAASjB;AAAAA,eAASkB,CAAAA,CAAAA,CAAAA,CAAEhB,CAAFgB,EAASpB,CAAAA,CAAOA,CAAAA,CAAOA,CAAAA,CAAO,EAAPA,EAAWQ,CAAXR,CAAPA,EAAiCE,CAAjCF,CAAPA,EAAgDH,CAAhDG,CAAToB,CAATlB;AAAkEL,OAbzD;AAayDA;;AAAAA,WAAAA,CAEzEQ,CAAAA,CAAQgB,SAARhB,GAAoB,IAAIiB,CAAAA,CAAAA,SAAJ,EAFqDzB,EAEpC0B,WAFoC1B,GAEtBQ,CAFsBR;AAEtBQ,GDrCtCV;ACqCsCU,CAiB7DmB,EAjB6DnB,OAAAA,CAAAA,QAAAA,GAAAA,CAiB7DmB","sourcesContent":["// Bind an object/factory of actions to the store and wrap them.\nexport function mapActions(actions, store) {\n\tif (typeof actions==='function') actions = actions(store);\n\tlet mapped = {};\n\tfor (let i in actions) {\n\t\tmapped[i] = store.action(actions[i]);\n\t}\n\treturn mapped;\n}\n\n\n// select('foo,bar') creates a function of the form: ({ foo, bar }) => ({ foo, bar })\nexport function select(properties) {\n\tif (typeof properties==='string') properties = properties.split(/\\s*,\\s*/);\n\treturn state => {\n\t\tlet selected = {};\n\t\tfor (let i=0; i<properties.length; i++) {\n\t\t\tselected[properties[i]] = state[properties[i]];\n\t\t}\n\t\treturn selected;\n\t};\n}\n\n\n// Lighter Object.assign stand-in\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n","import { h, Component } from 'preact';\nimport { assign, mapActions, select } from '../util';\n\n/**\n * Wire a component up to the store. Passes state as props, re-renders on change.\n * @param {Function|Array|String} mapStateToProps  A function mapping of store state to prop values, or an array/CSV of properties to map.\n * @param {Function|Object} [actions] \t\t\t\tAction functions (pure state mappings), or a factory returning them. Every action function gets current state as the first parameter and any other params next\n * @returns {Component} ConnectedComponent\n * @example\n * const Foo = connect('foo,bar')( ({ foo, bar }) => <div /> )\n * @example\n * const actions = { someAction }\n * const Foo = connect('foo,bar', actions)( ({ foo, bar, someAction }) => <div /> )\n * @example\n * @connect( state => ({ foo: state.foo, bar: state.bar }) )\n * export class Foo { render({ foo, bar }) { } }\n */\nexport function connect(mapStateToProps, actions) {\n\tif (typeof mapStateToProps!='function') {\n\t\tmapStateToProps = select(mapStateToProps || {});\n\t}\n\treturn Child => {\n\t\tfunction Wrapper(props, context) {\n\t\t\tconst store = context.store;\n\t\t\tlet state = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\tconst boundActions = actions ? mapActions(actions, store) : { store };\n\t\t\tlet update = () => {\n\t\t\t\tlet mapped = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\t\tfor (let i in mapped) if (mapped[i]!==state[i]) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.setState({});\n\t\t\t\t}\n\t\t\t\tfor (let i in state) if (!(i in mapped)) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.setState({});\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.componentWillReceiveProps = p => {\n\t\t\t\tprops = p;\n\t\t\t\tupdate();\n\t\t\t};\n\t\t\tthis.componentDidMount = () => {\n\t\t\t\tstore.subscribe(update);\n\t\t\t};\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tstore.unsubscribe(update);\n\t\t\t};\n\t\t\tthis.render = props => h(Child, assign(assign(assign({}, boundActions), props), state));\n\t\t}\n\t\treturn (Wrapper.prototype = new Component()).constructor = Wrapper;\n\t};\n}\n\n\n/**\n * Provider exposes a store (passed as `props.store`) into context.\n *\n * Generally, an entire application is wrapped in a single `<Provider>` at the root.\n * @class\n * @extends Component\n * @param {Object} props\n * @param {Store} props.store\tA {Store} instance to expose via context.\n */\nexport function Provider(props) {\n\tthis.getChildContext = () => ({ store: props.store });\n}\nProvider.prototype.render = props => props.children && props.children[0] || props.children;\n"]},"metadata":{},"sourceType":"script"}